import { Elysia } from "elysia";
import { jwt } from "@elysiajs/jwt";
import { prisma } from "../db";

const JWT_SECRET = process.env.JWT_SECRET || "default-secret-key";

/**
 * Authentication middleware for Elysia using @elysiajs/jwt
 * Verifies JWT token from Authorization header and fetches user from database
 */
export const isAuthenticated = new Elysia({ name: "isAuthenticated" })
  .use(
    jwt({
      name: "jwt",
      secret: JWT_SECRET,
    })
  )
  .derive(async ({ headers, set, jwt }) => {
    const authHeader = headers.authorization;

    // Check if Authorization header exists
    if (!authHeader) {
      set.status = 401;
      throw new Error("Authorization header is required");
    }

    // Extract token from "Bearer <token>" format
    const parts = authHeader.split(" ");
    if (parts.length !== 2 || parts[0] !== "Bearer") {
      set.status = 401;
      throw new Error("Invalid Authorization header format. Use: Bearer <token>");
    }

    const token = parts[1];

    try {
      // Verify token using @elysiajs/jwt
      const payload = await jwt.verify(token);

      if (!payload) {
        set.status = 401;
        throw new Error("Invalid or expired token");
      }

      // Get user ID from sub (subject) claim
      const userId = payload.sub || payload.userId;

      if (!userId) {
        set.status = 401;
        throw new Error("Invalid token payload: missing user ID");
      }

      // Fetch full user object from database
      const user = await prisma.user.findUnique({
        where: { id: userId as string },
        select: {
          id: true,
          email: true,
          role: true,
          createdAt: true,
        },
      });

      if (!user) {
        set.status = 401;
        throw new Error("User not found");
      }

      // Attach full user object to context (accessible via ctx.user)
      return {
        user,
      };
    } catch (error) {
      set.status = 401;
      throw new Error(error instanceof Error ? error.message : "Token verification failed");
    }
  });

// Legacy middleware for backward compatibility
export const authMiddleware = isAuthenticated;

/**
 * User role types from Prisma schema
 */
export type UserRole = "ADMIN" | "ORGANIZER" | "ATTENDEE";

/**
 * Role-based authorization middleware factory
 * Must be used after isAuthenticated middleware
 * @param roles - Array of allowed user roles
 * @returns Elysia middleware that checks if user has required role
 */
export const isRole = (roles: UserRole[]) => {
  return new Elysia({ name: "isRole" })
    .derive((context: any) => {
      const { user, set } = context;

      // Check if user exists (should be set by isAuthenticated)
      if (!user) {
        set.status = 401;
        throw new Error("User not authenticated");
      }

      // Check if user's role is in allowed roles
      if (!roles.includes(user.role as UserRole)) {
        set.status = 403;
        throw new Error(
          `Access denied. Required role(s): ${roles.join(" or ")}. Your role: ${user.role}`
        );
      }

      return {};
    });
};

/**
 * Role-based authorization middleware (legacy)
 * Checks if authenticated user has one of the required roles
 */
export const requireRole = (...allowedRoles: string[]) => {
  return new Elysia({ name: "requireRole" })
    .use(isAuthenticated)
    .derive((context: any) => {
      const { user, set } = context;

      if (!user || !allowedRoles.includes(user.role)) {
        set.status = 403;
        throw new Error("Insufficient permissions. Required role: " + allowedRoles.join(" or "));
      }

      return {};
    });
};

/**
 * Admin-only middleware (using isRole)
 * Ensures user has ADMIN role
 */
export const isAdmin = isRole(["ADMIN"]);

/**
 * Organizer or Admin middleware (using isRole)
 * Ensures user has ORGANIZER or ADMIN role
 */
export const isOrganizerOrAdmin = isRole(["ORGANIZER", "ADMIN"]);

/**
 * Attendee or above middleware (using isRole)
 * Allows ATTENDEE, ORGANIZER, or ADMIN roles
 */
export const isAttendeeOrAbove = isRole(["ATTENDEE", "ORGANIZER", "ADMIN"]);
/**
 * Admin-only middleware (legacy)
 * Ensures user has ADMIN role
 */
export const requireAdmin = requireRole("ADMIN");

/**
 * Organizer or Admin middleware (legacy)
 * Ensures user has ORGANIZER or ADMIN role
 */
export const requireOrganizer = requireRole("ORGANIZER", "ADMIN");ï¿¼Enter
